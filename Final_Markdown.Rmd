---
title: "432 Final Project Markdown"
author: "Clarisa Griffin"
date: "2025-03-30"
output: html_document
---

Github Link: https://github.com/CEGriffin/432-Final-Project

Group members: Clarisa Griffin (20270784), 

##Data Manipulation##

__Non-Normalized Data__
```{r, warning=F, message=F}
#load libraries
library(dplyr)
library(tidyverse)
library(tidyr)
library(ggplot2)

#load data
data<-read.csv("DataSynthesis.csv") #DataSynthesis.csv is pulled from Colautti et al., 2023

#separate out tag info into different lines

#create new columns to be turned into different aspects of the plant ID
#rename family to population, because theres another column that will actually eb the family
#remove un-needed columns
data<-data%>%
  rename(population=Family)%>%
  mutate(petri_dish=Tag) %>%
  mutate(family=Tag) %>%
  mutate(common_garden=Tag)%>%
  select(c("Tag", "petri_dish", "population", "family", "common_garden", "ID", starts_with("gh"), ends_with("Field"), starts_with("GM"), ends_with("Bolt"), starts_with("Chlor"), ends_with("Conc"), starts_with("RGR")), -c("GM_Fecundity", ends_with("Initial"), "GM_Leaf_Number"))

#use regular expressions to replace each plant ID column  with only the aspect of the ID needed
data$petri_dish<-sub("(\\w?).+","\\1", data$petri_dish)
data$family<-sub("\\w?\\|\\w+-([A-z0-9-]+)\\|.*", "\\1", data$family)
data$common_garden<-sub("\\w?\\|.+\\|(\\w)\\|.+", "\\1", data$common_garden)

#remove maple observations (we are only interested in garlic mustard)
data<-subset(data, population!="maple")

#remove observations for which there is no common garden data
unique(data$common_garden)
data<-subset(data, common_garden!="e|JBCHY1-1-50|?")
data<-subset(data, common_garden!="b|WSSWM3-1-0|?|?")
data<-subset(data, common_garden!="i163_2")

#Ensure columns are the right data class
str(data)
data$Tag<-as.factor(data$Tag)
data$petri_dish<-as.factor(data$petri_dish)
data$population<-as.factor(data$population)
data$family<-as.factor(data$family)
data$common_garden<-as.factor(data$common_garden)
data$ID<-as.factor(data$ID)

#impute missing data by replacing NA with the mean of the column for numerical variables
#"bolt" data will be done later- needs further manipulation
data<-data%>%
  mutate(RGR1=ifelse(is.na(RGR1),mean(data$RGR1, na.rm=T),RGR1),
         RGR2=ifelse(is.na(RGR2),mean(data$RGR2, na.rm=T),RGR2),
         RGR3=ifelse(is.na(RGR3),mean(data$RGR3, na.rm=T),RGR3),
         RGR4=ifelse(is.na(RGR4),mean(data$RGR4, na.rm=T),RGR4),
         ChlorA=ifelse(is.na(ChlorA),mean(data$ChlorA, na.rm=T),ChlorA),
         ChlorB=ifelse(is.na(ChlorB),mean(data$ChlorB, na.rm=T),ChlorB),
         gluc_Conc=ifelse(is.na(gluc_Conc),mean(data$gluc_Conc, na.rm=T),gluc_Conc),
         flav_Conc=ifelse(is.na(flav_Conc),mean(data$flav_Conc, na.rm=T),flav_Conc),
         GM_Leaf_Len=ifelse(is.na(GM_Leaf_Len),mean(data$GM_Leaf_Len, na.rm=T),GM_Leaf_Len),
         GM_Leaf_Wid=ifelse(is.na(GM_Leaf_Wid),mean(data$GM_Leaf_Wid, na.rm=T),GM_Leaf_Wid),
         GM_TotalLeaf_Area =ifelse(is.na(GM_TotalLeaf_Area),mean(data$GM_TotalLeaf_Area, na.rm=T),GM_TotalLeaf_Area),
         GM_NumberOfLeaves =ifelse(is.na(GM_NumberOfLeaves),mean(data$GM_NumberOfLeaves, na.rm=T),GM_NumberOfLeaves)
)

#create mortality column out of "bolt" data
#most of the bolt columns are "dead", will have to do analysis based on just mortality, then again with living bolt data
data<-data%>%
  mutate(mortality=Larg_Leaf_Len_Bolt)

data$mortality<-sub("\\d+","1", data$mortality)
data$mortality<-sub("Dead","0", data$mortality)

#separate out bolt data
bolt_data<-subset(data, Larg_Leaf_Len_Bolt!="Dead")

#Ensure columns are the right data class
bolt_data$Larg_Leaf_Len_Bolt<-as.numeric(bolt_data$Larg_Leaf_Len_Bolt)
bolt_data$Larg_Leaf_Wid_Bolt<-as.numeric(bolt_data$Larg_Leaf_Wid_Bolt)
bolt_data$GM_StemHeight_Bolt<-as.numeric(bolt_data$GM_StemHeight_Bolt)
bolt_data$GM_Leaf_Number_Bolt<-as.numeric(bolt_data$GM_Leaf_Number_Bolt)

#impute NAs
bolt_data<-bolt_data%>%
  mutate(Larg_Leaf_Len_Bolt=ifelse(is.na(Larg_Leaf_Len_Bolt),mean(data$Larg_Leaf_Len_Bolt, na.rm=T),Larg_Leaf_Len_Bolt),
         Larg_Leaf_Wid_Bolt=ifelse(is.na(Larg_Leaf_Wid_Bolt),mean(data$Larg_Leaf_Wid_Bolt, na.rm=T),Larg_Leaf_Wid_Bolt),
         GM_StemHeight_Bolt=ifelse(is.na(GM_StemHeight_Bolt),mean(data$GM_StemHeight_Bolt, na.rm=T),GM_StemHeight_Bolt),
         GM_NumberOfLeaves=ifelse(is.na(GM_NumberOfLeaves),mean(data$GM_NumberOfLeaves, na.rm=T),GM_NumberOfLeaves))

#write files into a csv
write.csv(data, file="./raw_data.csv", row.names=F)
write.csv(bolt_data, file="./raw_bolt_data.csv", row.names=F)

```


__Normalized Data__
```{r, warning=F, message=F}
#Check normality of numerical variables with histogram
long_data<-pivot_longer(data, c(12:23), names_to="metric", values_to="values")

ggplot(long_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")

#check for normality with qq plots
ggplot(long_data, aes(sample=values)) +
  geom_qq() +
  stat_qq_line() +
  facet_wrap(~metric, scales="free") #nothing looks too far from normal here, probably doesnt need any kind of normalization other than conversion to Z scores

#transform all numerical columns to z scores
data<-data%>%
  mutate(z_RGR1=(RGR1-mean(RGR1))/sd(RGR1),
         z_RGR2=(RGR2-mean(RGR2))/sd(RGR2),
         z_RGR3=(RGR3-mean(RGR3))/sd(RGR3),
         z_RGR4=(RGR4-mean(RGR4))/sd(RGR4),
         z_ChlorA=(ChlorA-mean(ChlorA))/sd(ChlorA),
         z_ChlorB=(ChlorB-mean(ChlorB))/sd(ChlorB),
         z_gluc_Conc=(gluc_Conc-mean(gluc_Conc))/sd(gluc_Conc),
         z_flav_Conc=(flav_Conc-mean(flav_Conc))/sd(flav_Conc),
         z_Leaf_Len=(GM_Leaf_Len-mean(GM_Leaf_Len))/sd(GM_Leaf_Len),
         z_Leaf_Wid=(GM_Leaf_Wid-mean(GM_Leaf_Wid))/sd(GM_Leaf_Wid),
         z_TotalLeaf_Area=(GM_TotalLeaf_Area-mean(GM_TotalLeaf_Area))/sd(GM_TotalLeaf_Area),
         z_NumberOfLeaves=(GM_NumberOfLeaves-mean(GM_NumberOfLeaves))/sd(GM_NumberOfLeaves))%>%
   select("Tag", "petri_dish", "population", "family", "common_garden", "ID", "gh_bench", "gh_col", "gh_row", "Row_Field", "Col_Field", starts_with("z_"), "mortality")

#how does it look after the transformation?
long_data<-pivot_longer(data, starts_with("z_"), names_to="metric", values_to="values")

ggplot(long_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")

#bolt data check for normality - needs log transformation
long_bolt_data<-pivot_longer(bolt_data, ends_with("Bolt"), names_to="metric", values_to="values")

ggplot(long_bolt_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")

#visualize with qq plot
ggplot(long_bolt_data, aes(sample=values)) +
  geom_qq() +
  stat_qq_line() +
  facet_wrap(~metric, scales="free") #also doesnt look too bad


#normalize bolt data and log transform
bolt_data<-bolt_data%>%
  mutate(Larg_Leaf_Len_Bolt=log(Larg_Leaf_Len_Bolt),
         Larg_Leaf_Wid_Bolt=log(Larg_Leaf_Wid_Bolt),
         GM_StemHeight_Bolt=log(GM_StemHeight_Bolt),
         GM_Leaf_Number_Bolt=log(GM_Leaf_Number_Bolt))%>%
  mutate(z_log_len_bolt=(Larg_Leaf_Len_Bolt-mean(Larg_Leaf_Len_Bolt))/sd(Larg_Leaf_Len_Bolt),
         z_log_wid_bolt=(Larg_Leaf_Wid_Bolt-mean(Larg_Leaf_Wid_Bolt))/sd(Larg_Leaf_Wid_Bolt),
         z_log_stemheight_bolt=(GM_StemHeight_Bolt-mean(GM_StemHeight_Bolt))/sd(GM_StemHeight_Bolt),
         z_log_leafnumber_bolt=(GM_Leaf_Number_Bolt-mean(GM_Leaf_Number_Bolt))/sd(GM_Leaf_Number_Bolt),
         z_RGR1=(RGR1-mean(RGR1))/sd(RGR1),
         z_RGR2=(RGR2-mean(RGR2))/sd(RGR2),
         z_RGR3=(RGR3-mean(RGR3))/sd(RGR3),
         z_RGR4=(RGR4-mean(RGR4))/sd(RGR4),
         z_ChlorA=(ChlorA-mean(ChlorA))/sd(ChlorA),
         z_ChlorB=(ChlorB-mean(ChlorB))/sd(ChlorB),
         z_gluc_Conc=(gluc_Conc-mean(gluc_Conc))/sd(gluc_Conc),
         z_flav_Conc=(flav_Conc-mean(flav_Conc))/sd(flav_Conc),
         z_Leaf_Len=(GM_Leaf_Len-mean(GM_Leaf_Len))/sd(GM_Leaf_Len),
         z_Leaf_Wid=(GM_Leaf_Wid-mean(GM_Leaf_Wid))/sd(GM_Leaf_Wid),
         z_TotalLeaf_Area=(GM_TotalLeaf_Area-mean(GM_TotalLeaf_Area))/sd(GM_TotalLeaf_Area),
         z_NumberOfLeaves=(GM_NumberOfLeaves-mean(GM_NumberOfLeaves))/sd(GM_NumberOfLeaves)) %>%
  select("Tag", "petri_dish", "population", "family", "common_garden", "ID", "gh_bench", "gh_col", "gh_row", "Row_Field", "Col_Field", starts_with("z_"), "mortality")


#check to see if the log transform did anything - looks much better
long_bolt_data<-pivot_longer(bolt_data, ends_with("bolt"), names_to="metric", values_to="values")

ggplot(long_bolt_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")

ggplot(long_bolt_data, aes(sample=values)) +
  geom_qq() +
  stat_qq_line() +
  facet_wrap(~metric, scales="free") #looks better

#write files into a csv
write.csv(data, file="./normalized_data.csv", row.names=F)
write.csv(bolt_data, file="./normalized_bolt_data.csv", row.names=F)
```


##PCA##

```{r}

#Load Libraries
library(dplyr)
library(ggplot2)

#Load data
pcaData<-read.csv("normalized_data.csv")

#select out the un-needed columns, leave columns with only data
pcaData_2<-pcaData %>%
  select(-c("Tag", "petri_dish", "population", "family", "ID",
            "gh_bench", "gh_col", "gh_row", "Row_Field", "Col_Field", "common_garden"))

#run PCA
plantPCA<-princomp(na.omit(pcaData_2),cor=F)

#checking the PCA output and its structure
str(plantPCA)
head(plantPCA)
names(plantPCA)

#put PCA loadings into a data frame
PCloadings<-data.frame(Component=c(1:13),Eigenvalue=plantPCA$sdev^2)

#create a scree plot - elbow is around 5.0 principal components
ggplot(aes(x=Component,y=Eigenvalue),data=PCloadings) +geom_point() + geom_line()

#what are the loadings of each variable on the components 
plantPCA$loadings

#combining the PCA with the original plant data for graphing 
plantCombined<-cbind(na.omit(pcaData), plantPCA$scores)

plantCombined<-plantCombined %>% 
  rename(PC1 = Comp.1, PC2 = Comp.2, PC3 = Comp.3, PC4= Comp.4, PC5 = Comp.5)

#make sure columns are the right data classes
str(plantCombined)

plantCombined$population<-as.factor(plantCombined$population)

#creating the bivariate plots for PC1 vs PC2 
ggplot(aes(x=PC1,y=PC2,colour=population, shape=common_garden),data=plantCombined)+
  geom_point() + theme_bw()

ggplot(aes(x=PC2,y=PC3,colour=population, shape=common_garden),data=plantCombined)+
  geom_point() + theme_bw()

ggplot(aes(x=PC1,y=PC3,colour=population, shape=common_garden),data=plantCombined)+
  geom_point() + theme_bw()



#checking if the data exhibits the same trend when including growth data when plants are bolts

#load data
boltData<-read.csv("normalized_bolt_data.csv", header=T)

#select out un-needed columns, keep only numerical variables
pcaData2<-boltData %>%
  select(-c("Tag", "petri_dish", "population", "family", "ID",
            "gh_bench", "gh_col", "gh_row", "Row_Field", "Col_Field", 
            "common_garden"))

#make PCA
boltPCA<-princomp(pcaData2,cor=F)

#checking the PCA output and its structure
str(boltPCA)
head(boltPCA)
names(boltPCA)

#put PCA loadings into a data frame
PCloadings2<-data.frame(Component=c(1:17),Eigenvalue=boltPCA$sdev^2)

#make a scree plot - elbow is around 5.0 principal components
ggplot(aes(x=Component,y=Eigenvalue),data=PCloadings2) +geom_point() + geom_line()

#what are the loadings of each variable on the components 
boltPCA$loadings

#combining the PCA with the original plant data for graphing 
boltCombined<-cbind(boltData, boltPCA$scores)

boltCombined<-boltCombined %>% 
  rename(PC1 = Comp.1, PC2 = Comp.2, PC3 = Comp.3, PC4= Comp.4, PC5 = Comp.5, 
         PC6=Comp.6)

str(boltCombined)

boltCombined$population<-as.factor(boltCombined$population)

#creating the bivariate plots for PC1 vs PC2, 2 vs 3, 1 vs 3
ggplot(aes(x=PC1,y=PC2,colour=population, shape=common_garden),data=boltCombined)+
  geom_point()+ theme_bw() 

ggplot(aes(x=PC2,y=PC3,colour=population, shape=common_garden),data=boltCombined)+
  geom_point()+ theme_bw()

ggplot(aes(x=PC1,y=PC3,colour=population, shape=common_garden),data=boltCombined)+
  geom_point()+ theme_bw()
```


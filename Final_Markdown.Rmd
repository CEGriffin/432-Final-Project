---
title: "432 Final Project Markdown"
author: "Clarisa Griffin"
date: "2025-03-30"
output: html_document
---

Github Link: https://github.com/CEGriffin/432-Final-Project

Group members: Clarisa Griffin (20270784), 

**Data Manipulation**
```{r}
#load libraries
library(dplyr)
library(tidyverse)
library(tidyr)
library(ggplot2)

#load data
data<-read.csv("DataSynthesis.csv") #DataSynthesis.csv is pulled from Colautti et al., 2023

#separate out tag info into different lines

#create new columns to be turned into different aspects of the plant ID
#rename family to population, because theres another column that will actually eb the family
#remove un-needed columns
data<-data%>%
  rename(population=Family)%>%
  mutate(petri_dish=Tag) %>%
  mutate(family=Tag) %>%
  mutate(common_garden=Tag)%>%
  select(c("Tag", "petri_dish", "population", "family", "common_garden", "ID", starts_with("gh"), ends_with("Field"), starts_with("GM"), ends_with("Bolt"), starts_with("Chlor"), ends_with("Conc"), starts_with("RGR")), -c("GM_Fecundity", ends_with("Initial"), "GM_Leaf_Number"))

#use regular expressions to replace each plant ID column  with only the aspect of the ID needed
data$petri_dish<-sub("(\\w?).+","\\1", data$petri_dish)
data$family<-sub("\\w?\\|\\w+-([A-z0-9-]+)\\|.*", "\\1", data$family)
data$common_garden<-sub("\\w?\\|.+\\|(\\w)\\|.+", "\\1", data$common_garden)

#remove maple observations (we are only interested in garlic mustard)
data<-subset(data, population!="maple")

#remove observations for which there is no common garden data
unique(data$common_garden)
data<-subset(data, population!="e|JBCHY1-1-50|?")
data<-subset(data, population!="b|WSSWM3-1-0|?|?")
data<-subset(data, population!="i163_2")

#Ensure columns are the right data class
str(data)
data$Tag<-as.factor(data$Tag)
data$petri_dish<-as.factor(data$petri_dish)
data$population<-as.factor(data$population)
data$family<-as.factor(data$family)
data$common_garden<-as.factor(data$common_garden)
data$ID<-as.factor(data$ID)

#impute missing data by replacing NA with the mean of the column for numerical variables
#"bolt" data will be done later- neets further manipulation
data<-data%>%
  mutate(RGR1=ifelse(is.na(RGR1),mean(data$RGR1, na.rm=T),RGR1),
         RGR2=ifelse(is.na(RGR2),mean(data$RGR2, na.rm=T),RGR2),
         RGR3=ifelse(is.na(RGR3),mean(data$RGR3, na.rm=T),RGR3),
         RGR4=ifelse(is.na(RGR4),mean(data$RGR4, na.rm=T),RGR4),
         ChlorA=ifelse(is.na(ChlorA),mean(data$ChlorA, na.rm=T),ChlorA),
         ChlorB=ifelse(is.na(ChlorB),mean(data$ChlorB, na.rm=T),ChlorB),
         gluc_Conc=ifelse(is.na(gluc_Conc),mean(data$gluc_Conc, na.rm=T),gluc_Conc),
         flav_Conc=ifelse(is.na(flav_Conc),mean(data$flav_Conc, na.rm=T),flav_Conc),
         GM_Leaf_Len=ifelse(is.na(GM_Leaf_Len),mean(data$GM_Leaf_Len, na.rm=T),GM_Leaf_Len),
         GM_Leaf_Wid=ifelse(is.na(GM_Leaf_Wid),mean(data$GM_Leaf_Wid, na.rm=T),GM_Leaf_Wid),
         GM_TotalLeaf_Area =ifelse(is.na(GM_TotalLeaf_Area),mean(data$GM_TotalLeaf_Area, na.rm=T),GM_TotalLeaf_Area),
         GM_NumberOfLeaves =ifelse(is.na(GM_NumberOfLeaves),mean(data$GM_NumberOfLeaves, na.rm=T),GM_NumberOfLeaves)
)

#Check normality of numerical variables with histogram
long_data<-pivot_longer(data, c(12:15, 20:27), names_to="metric", values_to="values")

ggplot(long_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")

#check for normality with qq plots - can use long data for this??
ggplot(data, aes(sample=RGR1)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=RGR2)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=RGR3)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=RGR4)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=ChlorA)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=ChlorB)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=gluc_Conc)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=flav_Conc)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=GM_Leaf_Len)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=GM_Leaf_Wid)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=GM_TotalLeaf_Area)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=GM_Leaf_Len)) +geom_qq() + stat_qq_line()
ggplot(data, aes(sample=GM_NumberOfLeaves)) +geom_qq() + stat_qq_line()

#transform all numerical columns (not bolt data) to z scores
data<-data%>%
  mutate(z_RGR1=(RGR1-mean(RGR1))/sd(RGR1),
         z_RGR2=(RGR2-mean(RGR2))/sd(RGR2),
         z_RGR3=(RGR3-mean(RGR3))/sd(RGR3),
         z_RGR4=(RGR4-mean(RGR4))/sd(RGR4),
         z_ChlorA=(ChlorA-mean(ChlorA))/sd(ChlorA),
         z_ChlorB=(ChlorB-mean(ChlorB))/sd(ChlorB),
         z_gluc_Conc=(gluc_Conc-mean(gluc_Conc))/sd(gluc_Conc),
         z_flav_Conc=(flav_Conc-mean(flav_Conc))/sd(flav_Conc),
         z_Leaf_Len=(GM_Leaf_Len-mean(GM_Leaf_Len))/sd(GM_Leaf_Len),
         z_Leaf_Wid=(GM_Leaf_Wid-mean(GM_Leaf_Wid))/sd(GM_Leaf_Wid),
         z_TotalLeaf_Area=(GM_TotalLeaf_Area-mean(GM_TotalLeaf_Area))/sd(GM_TotalLeaf_Area),
         z_NumberOfLeaves=(GM_NumberOfLeaves-mean(GM_NumberOfLeaves))/sd(GM_NumberOfLeaves))

#how does it look after the transformation?
long_data<-pivot_longer(data, starts_with("z_"), names_to="metric", values_to="values")

ggplot(long_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")

#create mortality column out of "bolt" data
#most of the bolt columns are "dead", will have to do analysis based on just mortality, then again with living bolt data
data<-data%>%
  mutate(mortality=Larg_Leaf_Len_Bolt)

data$mortality<-sub("\\d+","1", data$mortality)
data$mortality<-sub("Dead","0", data$mortality)

#separate out bolt data
bolt_data<-subset(data, Larg_Leaf_Len_Bolt!="Dead")

#Select out needed columns from "data"
data<-select(data, "Tag", "petri_dish", "population", "family", "common_garden", "ID", "gh_bench", "gh_col", "gh_row", "Row_Field", "Col_Field", starts_with("z_"), "mortality")

#Ensure columns are the right data class
bolt_data$Larg_Leaf_Len_Bolt<-as.numeric(bolt_data$Larg_Leaf_Len_Bolt)
bolt_data$Larg_Leaf_Wid_Bolt<-as.numeric(bolt_data$Larg_Leaf_Wid_Bolt)
bolt_data$GM_StemHeight_Bolt<-as.numeric(bolt_data$GM_StemHeight_Bolt)
bolt_data$GM_Leaf_Number_Bolt<-as.numeric(bolt_data$GM_Leaf_Number_Bolt)

#impute NAs
bolt_data<-bolt_data%>%
  mutate(Larg_Leaf_Len_Bolt=ifelse(is.na(Larg_Leaf_Len_Bolt),mean(data$Larg_Leaf_Len_Bolt, na.rm=T),Larg_Leaf_Len_Bolt),
         Larg_Leaf_Wid_Bolt=ifelse(is.na(Larg_Leaf_Wid_Bolt),mean(data$Larg_Leaf_Wid_Bolt, na.rm=T),Larg_Leaf_Wid_Bolt),
         GM_StemHeight_Bolt=ifelse(is.na(GM_StemHeight_Bolt),mean(data$GM_StemHeight_Bolt, na.rm=T),GM_StemHeight_Bolt),
         GM_NumberOfLeaves=ifelse(is.na(GM_NumberOfLeaves),mean(data$GM_NumberOfLeaves, na.rm=T),GM_NumberOfLeaves))

#bolt data check for normality - needs log transformation
long_bolt_data<-pivot_longer(bolt_data, ends_with("Bolt"), names_to="metric", values_to="values")

ggplot(long_bolt_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")

#normalize bolt data and log transform
bolt_data<-bolt_data%>%
  mutate(Larg_Leaf_Len_Bolt=log(Larg_Leaf_Len_Bolt),
         Larg_Leaf_Wid_Bolt=log(Larg_Leaf_Wid_Bolt),
         GM_StemHeight_Bolt=log(GM_StemHeight_Bolt),
         GM_Leaf_Number_Bolt=log(GM_Leaf_Number_Bolt))%>%
  mutate(z_log_len_bolt=(Larg_Leaf_Len_Bolt-mean(Larg_Leaf_Len_Bolt))/sd(Larg_Leaf_Len_Bolt),
         z_log_wid_bolt=(Larg_Leaf_Wid_Bolt-mean(Larg_Leaf_Wid_Bolt))/sd(Larg_Leaf_Wid_Bolt),
         z_log_stemheight_bolt=(GM_StemHeight_Bolt-mean(GM_StemHeight_Bolt))/sd(GM_StemHeight_Bolt),
         z_log_leafnumber_bolt=(GM_Leaf_Number_Bolt-mean(GM_Leaf_Number_Bolt))/sd(GM_Leaf_Number_Bolt)) %>%
  select("Tag", "petri_dish", "population", "family", "common_garden", "ID", "gh_bench", "gh_col", "gh_row", "Row_Field", "Col_Field", starts_with("z_"), "mortality")


#check to see if the log transform did anything - looks much better
long_bolt_data<-pivot_longer(bolt_data, ends_with("bolt"), names_to="metric", values_to="values")

ggplot(long_bolt_data, aes(x=values)) +
  geom_histogram() +
  theme_classic() +
  facet_wrap(~metric, scales="free")


#write files into a csv
write.csv(data, file="./normalized_data.csv", row.names=F)
write.csv(bolt_data, file="./normalized_bolt_data.csv", row.names=F)

```

